### 1、针对大促，对数据库都有哪些建议？哪些注意点？
不要在主服务器上进行备份等消耗服务器性能的操作，或者大促时停止这些操作。

### 2、有哪些因素会影响到数据库性能？
* 效率低下的SQL，80%的问题是由于慢查询导致的。
* 大量的并发和超高的CPU使用率
* 大量并发
    * CPU损耗
    * 磁盘IO
    * 网卡
    * 大表/大事务

### 3、大表会造成什么影响呢？
* 什么样的表可以称之为大表  
    * 记录行数巨大，单表超过千万行
    * 表数据文件巨大,表数据文件超过10G
* 大表对查询的影响
    * 慢查询：很难在一定的时间内过滤出所需要的数据
    * 建立索引需要很长的时间
    * 修改表结构需要长时间锁表
    * 风险：会造成长时间的主从延迟

### 4、简述下事务？
事务4个特性：
* 事务的原子性(ATOMICITY)
> 定义: 一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败,
> 对于一个事务,不可能只执行其中的一部分操作

* 一致性（Consistency）
> 定义： 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

* 事务的隔离性(ISOLATION)
> 定义: 隔离性要求一个事务对数据库中数据的修改,在未提交完成前对于其它事务是不可见的.

    * 隔离界别，SQL标准中定义的四种隔离级别
        * 读未提交(READ UNCOMMITED)
        * 读已提交(READ COMMITED)
        * 可重复读(REPEATABLE READ)
        * 可串行化(SERIALIZABLE)

隔离性越来越高，并发性越来越低  

    * Oracle  默认  读已提交
    * MySQL   默认  可重复读

查询隔离级别
```sql
show variables like '%ios%';
```

* 事务的持久性( DURABILITY )
> 定义: 一旦事务提交,则其所做的修改就会永久保存到数据库中。 此时即使系统崩溃,已经提交的修改数据也不会丢失。


### 5、什么是大事务？有什么风险？如果确实需要大事务，怎么降低影响？
> 定义:运行时间比较长,操作的数据比较多的事务  

风险:
* 锁定太多的数据,造成大量的阻塞和锁超时
* 回滚时所需时间比较长
* 执行时间长,容易造成主从延迟

解决办法：
* 1.避免一次处理太多的数据
* 2.移出不必要在事务中的SELECT操作


### 6、简述下MySQL的体系结构？
连接管理器 -> 查询缓存 -> 查询解析 -> 查询优化器 -> 存储引擎层
![avatar](images/mysql-struction.png)  

### 7、聊下你了解的MySQL的存储引擎，以及在工作中怎么选择合适的存储引擎？
* MyISAM：  my z[ei]m  
特征： 
> - 并发性与锁级别； 
> - MyISAM表支持全文索引；
> - MyISAM表支持数据压缩；

限制：
> 版本 < MySQL5.0时默认表大小为4G  
> 如存储大表则要修改MAX_Rows和AVG_ROW_LENGTH  
> 版本 > MySQL5.0时默认支持为256TB  

适用场景：
> 非事务型应用  
> 只读类应用  
> 空间类应用，比如GPS  

* Innodb：
> 适用表空间进行数据存储，会为每一个表建立独立的表空间。

系统表空间和独立表空间如何选择：
  
    * 比较：
        * 系统表空间无法简单的搜索文件大小
        * 独立表空间可以通过optimize table命令收缩系统文件
        * 系统表空间会产品IO瓶颈
        * 独立表空间可以同时向多个文件刷新数据
        
建议： 对Innodb使用独立表空间

> 特性：  
> Innodb是一种事务性存储引擎，完全支持事务的ACID特性  
> Redo Log和Undo Log来实现事务  
> Undo Log 未提交的事务信息存储

```sql
show variables like 'innodb_file_per_table';
show variables like 'innodb_log_buffer_size';
show variables like 'innodb_log_files_in_group';
```

Innodb支持行级锁
> 行级锁可以最大程度支持并发, 行级锁是由存储引擎实现的

* CSV引擎
  
特点：
> - 以CSV格式进行数据存储
> - 所有列必须都是不能为空NULL的
> - 不支持索引
> - 可以对数据文件直接编辑

使用场景： 适合作为数据交换的中间表

* Archive存储引擎：

特点：
> 只支持insert和select  
> 只允许在自增属性建立索引

使用场景： 日志和数据采集类应用

* Memory存储引擎：  

特点：
> - 也称HEAP存储引擎，所以数据保存在内存中  
> - 支持HASH索引和BTree索引，等值索引建议使用HASH，范围索引建议使用BTree  
> - 所有字段都为固定长度 varchar(10) = char(10)  
> - 不支持BLOG、TEXT等大字段  
> - Memory存储引擎使用表级锁

使用场景：
> - 用于查找或者是映射表，例如邮编和地区的对应表
> - 用于保存数据分析中产生的中间表
> - 用于缓存周期性聚合数据的结果表

* Federated存储引擎：

特点： 提供了访问远程MySQL服务器上表的方法

适用场景： 偶尔的统计分析以及手工查询

### 7、聊一下MySQL中的锁？
- 锁对主要作用是管理共享资源的并发访问
- 锁用于实现事务的隔离性

锁的类型：
- 共享锁（读锁）
- 独占锁（写锁）

锁的粒度：
- 表级锁
- 行级锁

### 8、对于数据库性能方面优化你有哪些建议呢？
- 数据库结构设计和SQL语句优化
- 数据层存储引擎的选择和参数配置，不建议几种存储引擎混合使用
- 系统选择及优化
- 硬件升级

### 9、数据库结构优化的目的是什么？
- 减少数据冗余
- 尽量避免数据维护中出现更新/插入/删除异常

    - 插入异常: 如果表中的某个实体随着另一个实体而存在
    - 更新异常: 如果更改表中的某实体的单独属性时,需要对多行进行更新
    - 删除异常: 如果删除表中的某实体会导致其他实体的消失

- 节约数据存储空间
- 提高查询效率

### 10、聊聊你对数据库设计范式的了解？
- 第一范式
    - 数据库表中的所有字段都只具有单一属性
    - 单一属性的列是由基本数据类型所构成的
    - 设计出来的表是二维表
    
- 第二范式
    - 要求一个表中只具有一个业务主键，没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
    - 第二范式（2NF）要求实体的属性完全依赖于主关键字。
    
- 第三范式：
    - 在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。

### 11、你觉得范式化、反范式化设计的优缺点有哪些？
范式化优点:
- 可以尽量的减少数据冗余
- 数据表更新快体积小
- 范式化的更新操作比反范式化更快
- 范式化的表通常比反范式化更小

范式化缺点:
- 对于查询需要对多个表进行关联
- 更难进行索引优化

反范式化优点:
- 可以减少表的关联
- 可以更好地进行索引优化

反范式化缺点:
- 存在数据冗余及数据维护异常
- 对数据的修改需要更多的成本

### 12、怎么选择合适的数据类型？
为表中的字段选择合适的数据类型：
> 当一个列可以选择多种数据类型时,应该优先考虑数字类型, 其次是日期或二进制类型, 最后是字符类型。  
> 对于相同级别的数据类型,应该优先选择占用空间小的数据类型
>   - tinyint 1字节   
>   - smallint 2字节
>   - mediumint 3字节
>   - int 4字节
>   - bigint 8字节

如何选择VARCHAR和CHAR类型: 
- VARCHAR类型的存储特点：  
    - varchar用于存储变长字符串,只占用必要的存储空间  
    - 列的最大长度小于255则只占用一个额外字节用于记录字符串长度.  
    - 列的最大长度大于255则要占用两个额外字节用于记录字符串长度
      
- VARCHAR长度的选择问题：  
    - 使用最小的符合需求的长度  
    - varchar(5)和varchar(200)存储'MySQL'字符串性能不同  
    - MySQL为了优化查询，在内存中使用定长的字符串缓存数据，所以写的越大越占用内存。  

- VARCHAR的适用场景：  
    - 字符串列的最大长度比平均长度大很多  
    - 字符串列很少被更新  
    - 使用了多字节字符集存储字符串
    
      
- CHAR类型的存储特点  
    - CHAR类型是定长的  
    - 字符串存储在CHAR类型的列中会删除末尾的空格  
    - CHAR类型的最大宽度为255  
    - CHAR类型适合存储所长度近似的值  
    - CHAR类型适合存储短字符串  

> 经常更新的字段选择char，避免字符串页分裂，增加存储碎片。  

如何存储日期数据  

- DATATIME类型  

    - 以YYYY-MM-DD HH:MM:SS[.fraction]格式存储日期时间  
    - datetime = YYYY-MM-DD HH:MM:SS  
    - datetime(6) = YYYY-MM-DD HH:MM:SS.fraction  
    - DATATIME类型与时区无关，占用8个字节的存储空间时间范围1000-01-01 00:00:00到9999-12-31 23:59:59
  
- TIMESTAMP类型
  
> 存储了由格林尼治时间1970年1月1日到当前时间的秒数
  
    - 以YYYY-MM-DD HH:MM:SS.[.fraction]的格式显示，占用4个字节时间范围1970-01-01到2038-01-19  
    - timestamp类型显示依赖于所指定的时区  
    - 在行的数据修改时可以自动修改timestamp列的值  

需要保持微秒，可以设置日志格式的宽度，如下即可在日期格式中保持微秒时间  
> datetime(6)  -> 2020-2-26 10:49:07.000000  
> timestamp(6) -> 2020-2-26 10:49:35.000000  

- date类型和time类型
  
    - date类型的优点:  
        - 1.占用的字节数比使用字符串、datetime、 int存储要少,使用date类型只需要3个字节  
        - 2.使用Date类型还可以利用日期时间函数进行日期之间的计算  

> date类型用于保存1000-01-01到9999-12-31之间的日期  
> time类型用于存储时间数据,格式为HH:MM:SS  

存储日期时间数据的注意事项  
> - 不要使用字符串类型来存储日期时间数据  
> - 日期时间类型通常比字符串占用的存储空间小  
> - 日期时间类型在进行查找过滤时可以利用日期来进行对比  
> - 日期时间类型还有着丰富的处理函数,可以方便地对时期类型进行日期计算    
> - 使用Int存储日期时间不如使用Timestamp类型  

### 13、你对MySQL数据库的设计规范建议？
- 所有表必须使用Innodb存储引擎
    - 5.6以后的默认引擘
    - 支持事务,行级锁,更好的恢复性,高并发下性能更好

- 数据库和表的字符集统一使用UTF8
    - 统一字符集可以避免由于字符集转换产成的乱码
    - MySQL中UTF8字符集汉字点3个字节, ASCII码占用1个字节

- 所有表和字段都需要添加注释
    - 使用comment从句添加表和列的备注
    - 从一开始就进行数据字典的维护

- 尽量控制单表数据量的大小,建议控制在500万以内
    - 500万并不是MySQL数据库的限制
    - 可以用历史数据归档,分库分表等手段来控制数据量大小

- 谨慎使用MySQL分区表
    - 分区表在物理上表现为多个文件,在逻辑上表现为一个表
    - 谨慎选择分区键,跨分区查询效率可能更低

- 禁止在表中建立预留字段
    - 预留字段的命名很难做到见名识义
    - 预留字段无法确认存储的数据类型,所以无法选择合适的类型
    - 对预留字段类型的修改,会对表进行锁定

- 禁止在数据库中存储图片,文件等进制数据

- 禁止在线上做数据库压力测试

- 禁止从开发环境,测试环境直连生产环境数据库

- 限制每张表上的索引数量,建议单张表索引不超过5个
    - 索引并不是越多越好!索引可以提高效率同样可以降低效率
    - 禁止给表中的每一列都建立单独的索引

- 每个Innodb表必须有一个主键
    - 不使用更新频繁的列作为主键,不使用多列主键
    - 不使用UUID , MD5 , HASH,字符串列作为主键
    - 主键建议选择使用自增ID值

### 14、索引设计规范，你觉得索引应该怎么设计？
- 常见索引列建议
    - SELECT、UPDATE、 DELETE语句的WHERE从句中的列
    - 包含在ORDER BY、GROUP BY、DISTINCT中的字段
    - 多表JOIN的关联列

- 如何选择联合索引列的顺序
    - 区分度最高列放在联合索引的最左侧
    - 尽量把字段长度小的列放在联合索引的最左侧
    - 使用最频繁列放到联合索引的左侧

- 避免建立冗余索引和重复索引
```sql
primary key(id)     index (id)      unique index(id)
index(a,b,c)        index(a,b)      index(a)
```

- 对于频繁查询优先考虑使用覆盖索引
    - 避免Innodb表进行索引的二次查找
    - 可以把随机IO变为顺序I0加快查询效率

- 尽量避免使用外键
    - 不建议使用外键约束,但一定在表与表之间的关联键上建立索引
    - 外键可用于保证数据的参照完整性,但建议在业务端实现
    - 外键会影响父表和子表的写操作从而降低性能

### 15、数据库字段设计时，有哪些优化建议呢？
- 优先选择符合存储需要的最小的数据类型
  
- 将字符串转化为数字类型存储      
    
    INET_ATON(‘255.255.255.255’) = 4294967295  
    INET_NTOA(4294967295) = ‘255.255.255.255’  
  
- 对于非负数据采用无符号整型进行存储  
    
    SIGNED INT      -21 47483648~21 47483647  
    UNSIGNED INT    0 ~ 4294967295  

  
- VARCHAR(N)中的N代表的是字符数,而不是字节数  
    - 使用UTF8存储汉字varchar(255)=765个字节  
    - 过大长度会消耗更多的内存  

- 避免使用TEXT/BLOB数据类型
    - TinyText
    - Text
    - MidumText
    - LongText

- 建议把BLOB或是TEXT列分离到单独的扩展表中，TEXT或BLOB类型只能使用前缀索引

- 避免使用ENUM数据类型
    - 修改ENUM值需要使用ALTER语句
    - ENUM类型的ORDER BY操作效率低,需要额外操作
    - 禁止使用数值作为ENUM的枚举值

- 尽可能把所有列定义为NOT NULL
    - 索引NULL列需要额外的空间来保存,所以要占用更多的空间
    - 进行比较和计算时要对NULL值做特别的处理

- 使用TIMESTAMP或DATETIME类型存储时间
    - TIMESTAMP 1970-01 -01 00:00:01 ~ 2038-01-19 03:14:07
    - TIMESTAMP占用4字节和INT相同,但比INT可读性高
    - 超出TIMESTAMP取值范围的使用DATETIME类型

- 同财务相关的金额类数据,必须使用decimal类型
    - Decimal类型为精准浮点数,在计算时不会丢失精度
    - 占用空间由定义的宽度决定
    - 可用于存储比bigint更大的整数数据

### 16、开发时，数据库SQL有哪些优化建议呢？
- 建议使用预编译语句进行数据库操作，只传参数,比传递SQL语句更高效，因为相同语句可以一次解析多次使用, 提高处理效率

- 避免数据类型的隐式转换，因为隐式转换会导致索引失效。  
比如： 
```sql
select name,phone from customer where id = '111'
```

- 充分利用表上已经存在的索引

- 避免使用双%号的查询条件，如 a like '%123%'

- 一个SQL只能利用到复合索引中的一列进行范围查询

- 使用left join或not exists来优化not in操作

- 程序连接不同数据库，使用不同的账号,禁止跨库查询，为数据库迁移和分库分表留出余地，降低业务耦合度，避免权限过大而产生的安全风险。  

- 禁止使用SELECT *必须使用SELECT <字段列表>查询
    - 消耗更多的CPU和IO以及网络带宽资源
    - 无法使用覆盖索引
    - 可减少表结构变更带来的影响

- 禁止使用不含字段列表的INSERT语句，可减少表结构变更带来的影响
```sql
insert into t values( 'a' ' b' ' c' ); 
insert into t (c1,c2,c3) values( 'a' ,' b';' c' ); 
```

- 避免使用子查询,可以把子查询优化为join操作
    - 子查询的结果集无法使用索引
    - 子查询会产生临时表操作,如果子查询数据量大则严重影响效率
    - 消耗过多的CPU及IO资源

- 避免使用JOIN关联太多的表
    - 每Join一个表会多占用一部分内存(join_buffer_size)
    - 会产生临时表操作,影响查询效率.
    - MySQL最多允许关联61个表，建议不超过5个

- 减少同数据库的交互次数
    - 数据库更适合处理批量操作
    - 合并多个相同操作到一起,可以提高处理效率
```sql
alter table t1 add column c1 int, change column c2 c2 int
```

- 使用in代替or
    - in的值不要超过500个
    - in操作可以有效的利用索引

- 禁止使用order by rand()进行随机排序
    - 会把表中所有符合条件的数据装载到内存中进行排序
    - 会消耗大量的CPU和IO及内存资源
    - 推荐在程序中获取一个随机值,然后从数据库中获取数据的方式

- WHERE从句中禁止对列进行函数转换和计算，对列进行函数转换或计算会导致无法使用索引
```sql
where date(createtime)= '20160901'
where createtime >= '20160901' and createtime < '20160902'
```

- 在明显不会有重复值时使用UNION ALL而不是UNION
    - UNION会把所有数据放到临时表中后再进行去重操作
    - UNION ALL不会再对结果集进行去重操作

- 拆分复杂的大SQL为多个小SQL
    - MySQL一个SQL只能使用一个CPU进行计算
    - SQL拆分后可以通过并行执行来提高处理效率

### 17、对大批量的数据库插入时，有什么好的建议吗？
- 超100万行的批量写操作,要分批多次进行操作
- 大批量操作可能会造成严重地主从延迟
- binlog日志为row格式时会产生大量的日志
- 避免产生大事务操作

### 18、对大表需要修改表结构时有哪些好的建议？
对于大表使用pt-online-schema-change修改表结构
- A：先将表进行复制；
- B：复制完成后，对复制的表进行表结构修改；
- C：将两个表的数据进行增量同步；
- D：将原表重命名；
- E：将复制的表改成原来的表名

pt-online-schema-change的好处：
- 避免大表修改产生的主从延迟
- 避免在对表字段进行修改时进行锁表

### 19、聊聊对分区表的理解呢？
在逻辑上为一个表,在物理上存储在多个文件中
```sql
CREATE TABLE `customer_login_log` (
    `customer_id` INT(10) UNSIGNED NOT NULL COMMENT '登录用户ID',
    `login_ime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '用户登录时间',
    `login_ip` INT(10) UNSIGNED NOT NULL COMENT '登录IP',
    `login_type` TINYINT(4) NOT NULL COMENT '录类型:0未成功1成功',
) ENGINE = INNOOB DEFAUILT CHARSET=utf8 CONMENT = '用户登录日志表'
PARTITION BY HASH(customer_id) PARTITIONS 4;
```

HASH分区的特点
- 跟据MOD(分区键,分区数)的值把数据行存储到表的不同分区中
- 数据可以平均地分布在各个分区中
- HASH分区的键值必须是一个INT类型的值,或是通过函数可以转为INT类型

```sql
ALTER TABLE `customer_login_log` ADD PARTITION (PARTITION p4 VALUES LESS THAN(2018)
```

使用分区表的注意事项：
- 结合业务场景选择分区键,避免跨分区查询
- 对分区表进行查询最好在WHERE从句中包含分区键
- 具有主键或唯一索引的表,主键或唯一索引必须是分区键的一部分

### 20、如何去分析一条SQL是否还有优化的空间呢？
执行计划能告诉我们什么?
- SQL如何使用索引
- 联接查询的执行顺序
- 查询扫描的数据行数

一个覆盖索引的使用案例(分页查询评论数)：
```sql
SELECT t.customer_id, t.title, t.content
FROM (
    SELECT comment_id
    FROM product_comment
    WHERE product_id=199727 AND audit_status=1 LIMIT 0, 15
) a JOIN product_comment t ON a.comment_id = t.comment_id;
```

因为商品的评论数比较多，所以分页查询，越往后面的页查询效率越低。   
而我们的评论ID是主键， 而product_id和评论状态是联合索引， 所以单独查询评论编号正好可以使用到索引覆盖，全内存操作，效率非常高。  
这样就消除了查询后面页效率低的问题。  

### 21、数据库复制解决了什么问题？
- 实现在不同服务器上的数据分布
- 利用二进制日志增量进行，不需要太多的带宽
- 但是使用基于行的复制在进行大批量的更改时，会对带宽带来一定的压力，特别是跨IDC环境下进行复制
- 实现数据读取的负载均衡
    - 需要其它组件配合完成
    - 利用DNS轮询的方式把程序的读连接到不同的备份数据库
    - 使用LVS , haproxy这样的代理方式
    - 非共享架构，同样的数据分布在多台服务器上
    
- 增强了数据安全性
    - 利用备库的备份来减少主库负载
    - 复制并不能代替备份
    
- 方便进行数据库高可用架构的部署，避免MySQL单点失败
    - 实现数据库高可用和故障切换
    - 实现数据库在线升级

### 22、聊聊你对MySQL日志的认识和看法呢？
基于段的格式binlog. format=STATEMENT
优点
●日志记录量相对较小,节约磁盘及网络I/O
只对一条记录修改或者插入，row格式所产生的日志量小于段产生的日志量
缺点
●特定函数如UUID(),user()这样非确定性函数还是无法复制
●可能造成MySQL复制的主备服务器数据不一致

基于行的日志格式binlog_ format= ROW 
Row格式可以避免MySQL复制中出现的主从不一致问题
同一SQL语句修改了10000条数据的情况下
基于段的日志格式只会记录这个SQL语句
基于行的日志会有10000条记录分别记录每一行的数据修改
优点
●使MySQL主从复制更加安全
●对每一行数据的修改比基于段的复制高效
缺点
●记录日志量较大.
binlog_ row_ jimage =[FULLMINIMAL|NOBLOB]
 误操作而修改了数据库中的数据,同时又没有备份可以恢复时我们就可以通过分析二进制日志,对日志中记录的数据修改操作做反向处理的方式来达到恢复数据的目的

混合日志格式binlog. format= MIXED
特点
●根据SQL语句由系统决在基于段和基于行
的日志格式中进行选择
●数据量的大小由所执行的SQL语句决定

基于SQL语名的复制( SBR)
二-进制日志格式使用的是statement格式
基于行的复制( RBR )
二进制日志格式使用的是基于行的日志格式
混合模式
根据实际内容在以上两者间切换


如何选择二进制日志的格式
建议
binlog_format=mixed
如果同机房的数据建议如下配置
binlog_format=row
binlog_row_image=minimal

基于SQL语名的复制( SBR )
优点
●生成的日志量少,节约网络转输I/0
●并不强制要求主从数据库的表定义完全相同
●相比于基于行的复制方式更为灵活
缺点
●对于非确定性事件,无法保证主从复制数据的一致性
●对于存储过程,触法器，自定义函数进行的修改也可
能造成数据不一致
●相比于基于行的复制方式在从上执行时需要更多的行锁

基于行的复制( RBR )
优点
●可以应用于任何SQL的复制包括非确定函数,存储过程等
●可以减少数据库锁的使用
```sql
insert into order_cnt(timestr,total,amount) select date(order_date),count(*),sum(amount) from order group by date(order_date);
```
缺点
●要求主从数据库的表结构相同,否则可能会中断复制
●无法在从上单独执行触法器

对主从数据的一致性更加有保证基于行的复制( RBR )

### 23、主从复制的工作流程是这么样的？
①Master变更时将数据写入二进制日志（Binary log）
②Slave启动I/O Thread从Master读取二进制日志，放到本地的Relay Log中
复制数据时为了保证数据的完整性，有两种复制方式
基于日志点的复制
基于GTID的复制
③Slave启动SQL Thread线程通过Relay Log将数据回放到数据库中
基于SQL段的日志是在从库上重新执行记录的SQL
基于行的日志则是在从库上直接应用对数据库行的修改

### 24、聊聊主从基于日志的数据复制的理解？
日志分类：
- MySQL服务层日志
- 二进制日志、慢查日志、通用日志
- MySQL存储引擎层日志
- Innodb中有：重做日志、回滚日志

二进制日志
> 记录了所有对MySQL数据库的修改事件，包括增删改查事件和对表结构的修改事件